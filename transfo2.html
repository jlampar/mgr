<!DOCTYPE html>
<html>
<head>
	<title>Transformacja anamorficzna</title>
	<meta charset="utf-8">
	<style>
	.hide {
		display: none;
	}
	
	#PB {
		width: 40px;
		height: 40px;
		border: solid 2px black;
		display: inline-block;
	}

	#NB {
		width: 40px;
		height: 40px;
		border: solid 2px black;
		display: inline-block;
	}

	#basket {
		width: 810px;
		height: 810px;
		display: inline-block;
	}

	#container {
		margin: 100px;
	}

	</style>
	<script src="/var/cartovariables.js"></script>
</head>
<body>
<script src="http://d3js.org/d3.v4.min.js"></script>
<script src="http://d3js.org/d3.v3.min.js"></script>
<script src="https://d3js.org/d3-geo.v1.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/kute.js/1.6.2/kute.min.js"></script>
<script src="https://cdn.jsdelivr.net/kute.js/1.6.2/kute-svg.min.js"></script>
<div id="PB" class='unclickedPB'></div>
<div id="basket"></div>
<div id="NB" class='unclickedNB'></div>
<script>
	
	/*
	Skrypt transformuje granice Polski pomiedzy roznymi stadiami rozmycia Gaussa macierzy populacji w metodzie kartogramu anamorficznego Gastnera-Newmana.
	Kartogram zostal przeliczony w zewnetrznym programie, na strone ladowane sa pliki GeoJSON, zamieniane w sciezki SVG i przeksztalcane miedzy soba
	*/

	var w = 900;
	var h = 900;
	
	var svg = d3.select(document.getElementById("basket"))
		.append("svg")
		.attr("width", w-90)
		.attr("height", h-90)
		.attr("id", "SVG");

	var g = svg.append("g")
		.attr("id", "container");

	var mercator = d3.geoMercator()
		.fitSize([w-100, h-100], init);

			var geoPathInit = d3.geoPath().projection(mercator);
			g.append("g")
			.attr("id", "init")
    		.selectAll("path")
    		.data(init.features)
    		.enter()
    		.append("path")
    		.attr("id", function(d) {return d.properties.wojewodztw + '_init';})
    		.attr("d", geoPathInit)
			.style({
				fill: "#ccc",
				stroke: "black"
			});
			
			//w celu unikniecia asynchroniczonosci funkcji d3.json i zaprogramowania petli, wczytywanie plikow GeoJSON nastepuje przez zmienne z pliku cartovaribles.js
			var varList = [init,c500,c250,c200,c150,c100,c90,c80,c70,c60,c50,c40,c30,c20,c15,c10,c5,c1];

			for (var i=0; i<varList.length;i++) {
				item = varList[i];
				var geoPath = d3.geoPath().projection(mercator);
				g.append("g")
					.attr("id", i)
					.attr("class", "hide")
					.selectAll("path")
					.data(item.features)
					.enter()
					.append("path")
					.attr("id", function(d) {return d.properties.wojewodztw + i;})
					.attr("d", geoPath)
					.style({
				fill: "#ccc",
				stroke: "black"});
			};

			//funkcja clone pochdzi z narzedzia do szukania najlepszego obrotu sciezek transformowanych biblioteki KUTE.js: http://codepen.io/thednp/pen/YGayLg
			clone = function(a) {
      			var copy;
      			if (a instanceof Array) {
        			copy = [];
        			for (var i = 0, len = a.length; i < len; i++) {
          				copy[i] = clone(a[i]);
        			}
        			return copy;
      			}
      			return a;
    		};

    		pathParser = function(ID) {
    			if(document.getElementById(ID)) {
    				var str = document.getElementById(ID).getAttribute("d");
    				var qstr = '"'+String(str)+'"';
    				var noMZPath = qstr.replace(/[MZ]/g,'');
    				var cleanPath = noMZPath.replace(/[L]/g,' ');
    				var slicedPath = cleanPath.split(' ');
    				var coordArray = []
    				for(var r=0;r<slicedPath.length;r++) {
    					coordArray.push(slicedPath[r].replace(/["]/g,''));
    				};
    				var xArray = [], yArray = [];
    				for(var g=0;g<coordArray.length;g++) {
    					xArray.push(coordArray[g].split(',')[0]);
    					yArray.push(coordArray[g].split(',')[1]);
    				};
    				coo = [];
    				for(var h=0;h<xArray.length;h++) {
    					coo.push([parseFloat(xArray[h]),parseFloat(yArray[h])]);
    				};
    				return coo;
    			};
    		};
    		
    		//fragment funkcji bestIndex pochdzi z narzedzia do szukania najlepszego obrotu sciezek transformowanych biblioteki KUTE.js: http://codepen.io/thednp/pen/YGayLg
    		bestIndex = function(IDenter,IDexit) {
    			if(document.getElementById(IDenter) && document.getElementById(IDexit)) {
    				enterPath = pathParser(IDenter);
    				exitPath = pathParser(IDexit);
    				var enterClone = clone(enterPath);
					var exitClone = clone(exitPath);
    				var dxy = [], dx, dy;
    				for(var i=0;i<exitClone.length;i++) {
    					numerator = exitClone.splice(i,exitPath.length - i);
						exitClone = numerator.concat(exitClone);
    					dx = Math.abs(enterClone[i][0] - exitClone[i][0]);
    					dy = Math.abs(enterClone[i][1] - exitClone[i][1]);
    					dxy.push(Math.sqrt(dx*dx + dy*dy));
    					exitClone = []; exitClone = clone(exitPath); numerator = null;
    				};
    				return dxy.indexOf(Math.min.apply(null,dxy));
    			};
    		};
    		
    		//gotowa funkcja, ktora sprawdza sciezke wejsciowa i docelowa, znajduje najlepszy obrot i czeka na wywolanie
    		twn = function(ID1,ID2) {
    			if(document.getElementById(ID1) && document.getElementById(ID2)) {
    				enID = document.getElementById(ID1);
    				exID = document.getElementById(ID2);
    				enPath = document.getElementById(ID1).getAttribute("d");
    				exPath = document.getElementById(ID2).getAttribute("d");
    				var tween = KUTE.fromTo(enID, 
    					{path: enID},
    					{path: exID},
    					{
    						morphPrecision: 1,
    						morphIndex: bestIndex(enID,exID),
    						easing: 'easingElasticInOut',
    						duration: 500
    					});
    				return tween;
    			};
    			
    		};
    		
    		var actualStatus = 0;

    		document.getElementById('NB').onclick = function() {
    			if (actualStatus < varList.length) {
    				var preNext = actualStatus + 1;
    				var nextTarget = String(preNext);
    				if (document.getElementById("init") && document.getElementById(nextTarget)) {
    					var dispList = [];
    					var nextList = [];
    					var dispObject = document.getElementById("init");
    					var nextObject = document.getElementById(nextTarget);
    					for (var num=0; num < dispObject.childNodes.length; num++) {
   							dispList.push(dispObject.childNodes[num].id);
   							nextList.push(nextObject.childNodes[num].id);
    						};
    					var tweenArray = [];
    					for (var tnum=0; tnum < dispList.length; tnum++) {
    						tweenArray.push([dispList[tnum],nextList[tnum]]);
    						};
    					var varArray = [];
    					for (var vnum=0; vnum < tweenArray.length; vnum++) {
    						varArray.push(twn(tweenArray[vnum][0],tweenArray[vnum][1]));
    						};
    					actualStatus += 1;
    					nextStart = [];
    					for(var ALO=0; ALO < varArray.length; ALO++){
   							nextStart.push(varArray[ALO].start());
    						};
    					return nextStart;
    					};
    				};	
    			};

    		document.getElementById('PB').onclick = function() {
    			if (actualStatus >= 0) {
    				var prePrev = actualStatus - 1;
    				var prevTarget = String(prePrev);
    				if (document.getElementById("init") && document.getElementById(prevTarget)) {
   						var disppList = [];
   						var prevList = [];
   						var disppObject = document.getElementById("init");
    					var prevObject = document.getElementById(prevTarget);
    					for (var numm=0; numm < disppObject.childNodes.length; numm++) {
    						disppList.push(disppObject.childNodes[numm].id);
    						prevList.push(prevObject.childNodes[numm].id);
    						};
    					var tweennArray = [];
    					for (var tnumm=0; tnumm < disppList.length; tnumm++) {
    						tweennArray.push([disppList[tnumm],prevList[tnumm]]);
   							};
   						var varrArray = [];
    					for (var vnumm=0; vnumm < tweennArray.length; vnumm++) {
    						varrArray.push(twn(tweennArray[vnumm][0],tweennArray[vnumm][1]));
    						};
    					actualStatus -= 1;
   						prevStart = [];
   						for(var ALT=0; ALT < varrArray.length; ALT++){
    						prevStart.push(varrArray[ALT].start());
    						};			
    					return prevStart;
    					};
    				};
    			};

</script>
</body>
</html>